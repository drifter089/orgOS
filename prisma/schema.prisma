// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
    directUrl = env("DIRECT_URL")

}

model Post {
    id        Int      @id @default(autoincrement())
    name      String
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([name])
}

model Task {
    id          String   @id @default(cuid())
    title       String
    description String?
    completed   Boolean  @default(false)
    priority    Int      @default(0)
    userId      String
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    @@index([userId])
    @@index([completed])
}

// Team Management System Models

model Team {
    id             String   @id @default(cuid())
    name           String
    description    String?
    organizationId String   // WorkOS organization ID
    createdBy      String   // WorkOS user ID

    // Store React Flow state as JSON
    reactFlowNodes Json     @default("[]") // Array of RF nodes with positions
    reactFlowEdges Json     @default("[]") // Array of RF edges
    viewport       Json?    // { x, y, zoom } for canvas position

    // Public sharing (optional)
    shareToken       String?  @unique // UUID for public access
    isPubliclyShared Boolean  @default(false)

    roles          Role[]
    metrics        Metric[]
    editSession    EditSession?

    createdAt      DateTime @default(now())
    updatedAt      DateTime @updatedAt

    @@index([organizationId])
    @@index([createdBy])
}

// Edit session for multi-user blocking
// Tracks which user is currently editing a team canvas
model EditSession {
    id        String   @id @default(cuid())
    teamId    String   @unique // One active session per team
    userId    String            // WorkOS user ID
    userName  String?           // Display name for UI
    startedAt DateTime @default(now())
    lastSeen  DateTime @updatedAt // Updated by heartbeat

    team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)

    @@index([teamId])
    @@index([userId])
}

model Role {
    id             String   @id @default(cuid())
    teamId         String

    // Role properties (user-defined)
    title          String
    purpose        String   @db.Text
    accountabilities String? @db.Text
    metricId       String?  // Optional metric reference
    effortPoints   Int?     // Story points (1, 2, 3, 5, 8, 13, 20, 40)

    // Optional assignment
    assignedUserId String?  // WorkOS user ID

    // Visual properties (synced with React Flow node)
    nodeId         String   // React Flow node ID (for syncing)
    color          String   @default("#3b82f6") // Hex color

    team           Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
    metric         Metric?  @relation(fields: [metricId], references: [id])

    createdAt      DateTime @default(now())
    updatedAt      DateTime @updatedAt

    @@index([teamId])
    @@index([metricId])
    @@index([assignedUserId])
}

model Metric {
    id             String   @id @default(cuid())
    name           String   // e.g., "GitHub Stars", "YouTube Views"
    description    String?
    organizationId String   // WorkOS organization ID
    teamId         String?  // Optional team association

    // Integration-backed metrics
    integrationId  String?  // Reference to Integration connectionId
    templateId     String?  // Template identifier (e.g., "github-stars-total")
    endpointConfig Json?    // Endpoint parameters (e.g., {videoId: "abc123"})
    lastFetchedAt  DateTime? // Last data refresh timestamp

    // NEW: Polling configuration
    pollFrequency  String    @default("daily")  // "frequent", "hourly", "daily", "weekly", "manual"
    nextPollAt     DateTime?                     // When to poll next
    lastError      String?   @db.Text            // Last error message

    team              Team?             @relation(fields: [teamId], references: [id], onDelete: Cascade)
    integration       Integration?      @relation(fields: [integrationId], references: [connectionId], onDelete: Cascade)
    roles             Role[]            // One metric can be used by many roles
    dashboardCharts   DashboardChart[]  // Dashboard chart configurations using this metric
    dataPoints        MetricDataPoint[] // Relation to data points
    goal              MetricGoal?       // Optional goal for this metric
    apiLogs           MetricApiLog[]    // History of API calls (for debugging)

    createdAt      DateTime @default(now())
    updatedAt      DateTime @updatedAt

    @@index([organizationId])
    @@index([teamId])
    @@index([name])
    @@index([integrationId])
    @@index([nextPollAt])  // NEW: For polling queries
}

// Nango Integration Connections

model Integration {
    id             String   @id @default(cuid())

    // Nango connection identifiers
    connectionId   String   @unique // UUID from Nango (required for API calls)
    providerId     String   // Provider name: 'github', 'google', 'slack', etc.

    // User-defined display name (e.g., "Work GitHub", "Personal")
    displayName    String?

    // Ownership (organization-level connections)
    organizationId String   // WorkOS organization ID
    connectedBy    String   // WorkOS user ID who authorized the connection

    // Connection state
    status         String   @default("active") // "active", "revoked", "error", "expired"

    // Provider-specific data
    metadata       Json?    // Scopes, token expiry, provider user info, etc.

    // Audit trail
    lastSyncAt     DateTime? // Last successful API call
    errorMessage   String?   // Last error if status = "error"

    metrics        Metric[] // Metrics using this integration

    createdAt      DateTime @default(now())
    updatedAt      DateTime @updatedAt

    @@index([organizationId])
    @@index([connectionId])
    @@index([connectedBy])
    @@index([providerId])
    @@index([status])
}

// Dashboard & Visualization System

model DashboardChart {
    id             String   @id @default(cuid())
    organizationId String   // WorkOS organization ID
    metricId       String   // Metric being displayed

    // Chart configuration
    chartType      String   // "line", "bar", "area", "pie", "kpi"
    chartConfig    Json     @default("{}") // Labels, colors, axis titles, etc.

    // Layout properties
    position       Int      @default(0) // Display order
    size           String   @default("medium") // "small", "medium", "large"

    // Chart transformer relation
    chartTransformerId String?        @unique
    chartTransformer   ChartTransformer?

    metric         Metric   @relation(fields: [metricId], references: [id], onDelete: Cascade)

    createdAt      DateTime @default(now())
    updatedAt      DateTime @updatedAt

    @@index([organizationId])
    @@index([metricId])
    @@index([position])
}

// Systems Canvas - Visual KPI relationship mapping
model SystemsCanvas {
    id             String   @id @default(cuid())
    organizationId String   @unique // One canvas per organization

    // Store only positions and edges (metric data is in DashboardChart)
    // Node IDs match DashboardChart.id for linking
    reactFlowNodes Json     @default("[]") // Array of { id, position }
    reactFlowEdges Json     @default("[]") // Array of edge connection data
    viewport       Json?    // { x, y, zoom } for canvas position

    createdAt      DateTime @default(now())
    updatedAt      DateTime @updatedAt

    @@index([organizationId])
}

// NEW: Metrics Architecture Tables

// MetricDataPoint - Time-series storage for ALL metrics
// Single table for ALL metrics. No table-per-template.
model MetricDataPoint {
    id        String   @id @default(cuid())
    metricId  String
    metric    Metric   @relation(fields: [metricId], references: [id], onDelete: Cascade)

    // Time dimension - always required
    timestamp DateTime

    // Primary value - always filled
    value     Float

    // Secondary values - optional, for additional related data
    // e.g., {"additions": 500, "deletions": 200} or {"likes": 50, "comments": 10}
    dimensions Json?

    createdAt DateTime @default(now())

    // Indexes for time-series queries
    @@index([metricId, timestamp(sort: Desc)])
    @@index([timestamp(sort: Desc)])

    // Prevent duplicate data points for same metric at same timestamp
    @@unique([metricId, timestamp])
}

// Goal Types
enum GoalType {
    ABSOLUTE // Reach target value (e.g., reach 1000 subscribers)
    RELATIVE // Grow by percentage (e.g., grow by 10%)
}

// MetricGoal - One goal per metric
// Note: Goal period is determined by the chart's cadence (ChartTransformer.cadence)
// This ensures goal calculation uses the same aggregation as the chart display
model MetricGoal {
    id          String     @id @default(cuid())
    metricId    String     @unique // One goal per metric
    metric      Metric     @relation(fields: [metricId], references: [id], onDelete: Cascade)

    goalType    GoalType
    targetValue Float      // For ABSOLUTE: target number; For RELATIVE: percentage (e.g., 10 for 10%)

    createdAt   DateTime   @default(now())
    updatedAt   DateTime   @updatedAt

    @@index([metricId])
}

// DataIngestionTransformer - AI-generated code that transforms API data into DataPoints
// One per template. Shared across ALL orgs. Endpoint config comes from template definition.
model DataIngestionTransformer {
    id              String   @id @default(cuid())
    templateId      String   @unique

    // AI-generated JavaScript code: (apiResponse, endpointConfig) => DataPoint[]
    transformerCode String   @db.Text

    // What does the value field represent? (e.g., "commits", "stars", "views", "issues")
    // AI generates this once when creating the transformer
    valueLabel      String?

    // Documentation of what this transformer does
    // Helps debugging and understanding the endpoint
    // Example: "Extracts commit data from GitHub API. value = commit count per day.
    //          dimensions.additions = lines added, dimensions.deletions = lines deleted.
    //          Data is aggregated daily by commit date."
    dataDescription String?  @db.Text

    createdAt       DateTime @default(now())
    updatedAt       DateTime @updatedAt

    @@index([templateId])
}

// Cadence - How data is aggregated for chart display
enum Cadence {
    DAILY   // One data point per day
    WEEKLY  // One data point per week (Monday-Sunday)
    MONTHLY // One data point per month
}

// ChartTransformer - Transforms DataPoints into ChartConfig
// One per DashboardChart. User-specific.
model ChartTransformer {
    id               String @id @default(cuid())
    dashboardChartId String @unique
    dashboardChart   DashboardChart @relation(fields: [dashboardChartId], references: [id], onDelete: Cascade)

    // Transformation code (TypeScript)
    transformerCode String @db.Text  // Code: DataPoint[] â†’ ChartConfig

    // Chart configuration
    chartType    String    // "line", "bar", "area", "pie", etc.
    cadence      Cadence   @default(DAILY) // How to aggregate data for display

    // Generation context
    userPrompt   String?   @db.Text // User's natural language request

    version   Int @default(1)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([dashboardChartId])
}

// MetricApiLog - Stores raw API responses for debugging
// History of API calls for a metric (dev tool)
model MetricApiLog {
    id             String   @id @default(cuid())
    metricId       String
    metric         Metric   @relation(fields: [metricId], references: [id], onDelete: Cascade)

    // Raw API response (stored as JSON)
    rawResponse    Json

    // Metadata
    fetchedAt      DateTime @default(now())
    endpoint       String?  // The endpoint that was called
    endpointConfig Json?    // Parameters used for the call

    // Status tracking
    success        Boolean  @default(true)
    error          String?  @db.Text

    @@index([metricId, fetchedAt(sort: Desc)])
}